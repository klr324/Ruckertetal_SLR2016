lowstatusPerc <- Boston[,13]
plot(industryacres, lowstatusPerc)
plot(industryacres, lowstatusPerc, type="l")
industryacres <- order(Boston[,3])
industryacres <- order(Boston[,3], decreasing=FALSE)
data(Boston)
industryacres <- order(Boston[,3], decreasing=FALSE)
data(Boston)
industryacres <- Boston[,3]
lowstatusPerc <- Boston[,13]
industryacres <- order(industryacres, decrease=TRUE)
industryacres
industryacres <- order(industryacres, decreasing=TRUE)
industryacres
plot(industryacres)
plot(industryacres, type="l")
economicoutput=seq(from=1, to=100, length.out=50)
product=seq(from=10, to=75, length.out=50)
plot(economicoutput, product)
plot(economicoutput, rev(product))
plot(rev(product), economicoutput)
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
View(Objectives)
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
library(DT)
install.packages('DT')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
plot(-4:4, -4:4, pch=32)
points(rnorm(200), rnorm(200), col = "red", pch=33)
points(rnorm(200), rnorm(200), col = "red", pch=32)
points(rnorm(200), rnorm(200), col = "red", pch=34)
points(rnorm(200), rnorm(200), col = "red", pch=35)
points(rnorm(200), rnorm(200), col = "red", pch=36)
points(rnorm(200), rnorm(200), col = "red", pch=37)
points(rnorm(200), rnorm(200), col = "red", pch=40)
points(rnorm(200), rnorm(200), col = "red", pch=39)
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
install.packages('rsconnect')
library(rsconnect)
rsconnect::setAccountInfo(name='clima', token='D04D9D79F6CB492DACEFF4284EAE757D', secret='1Y4Lf8ep4lTA9C7MpRMQ3eZCBqlCLkVTVTanUtCJ')
shiny::runApp('Downloads/ShinyApps/NOLA_DST/option2')
plot(1:2, 2:3, pch=20,xlab="x", ylab="y")
rep(0,4)
par = c(1,2,3,4,5)
bound_lower = par -2
bound_upper = par +2
in_range = all(par > bound_lower) & all(par < bound_upper)
in_range
install_github("OpenMORDM/rgl@working")
install.packages("devtools")
install.packages("rgl")
library(devtools)
install_github("OpenMORDM/rdyncall")
install_github("OpenMORDM/shinyRGL")
install_github("OpenMORDM/OpenMORDM")
install_github("OpenMORDM/rgl@working")
.Platform$OS.type
install.packages('mcmc')
burnin = 1:10
data = rnorm(100)
data
data[-burnin]
install.packages("devtools")
install.packages("rgl")
library(devtools)
install_github("OpenMORDM/rdyncall")
install_github("OpenMORDM/shinyRGL")
install_github("OpenMORDM/OpenMORDM")
install_github("OpenMORDM/rgl@working")
library(OpenMORDM)
shiny::runApp('Downloads/d19ad051da5542bab1b715fbe388dd77')
library(rglwidget)
runApp('Downloads/d19ad051da5542bab1b715fbe388dd77')
runApp('Downloads/d19ad051da5542bab1b715fbe388dd77')
exp(-1)
exp(1)
exp(5)
exp(-5)
install.packages("animation") # downloads the animation package from CRAN
require("animation") # loads the animation package
# from help(quincunx)
quincunx(balls = 200, layers = 15, pch.layers = 2, pch.balls = 19,
col.balls = sample(colors(), balls, TRUE), cex.balls = 2)
ani.options(nmax = 14) # sets the number of animation frames
balls = 200
quincunx(balls = 200, layers = 15, pch.layers = 2, pch.balls = 19,
col.balls = sample(colors(), balls, TRUE), cex.balls = 2)
balls = 200
quincunx(balls = 200, layers = 15, pch.layers = 2, pch.balls = 19,
col.balls = sample(colors(), balls, TRUE), cex.balls = 2)
ani.options(nmax = 14) # sets the number of animation frames
quincunx(balls = 1) # runs the animation
n.balls <- 200 # sets the number of balls to drop
n.rows <- 15 # sets the number of rows of pins in the Galton board
ani.options(nmax = n.balls+ n.rows- 2)
quincunx(balls = n.balls, layers = n.rows)
P = [.8 .15 .05;  # SUNNY
.4 .5  .1;   # FOGGY
.1 .3  .6];  # RAINY
P = matrix(c(0.8, 0.15, 0.5),
c(0.4, 0.5,  0.1),
c(0.1, 0.3,  0.6),
nrow=3, ncol=3)
SUNNY = c(0.8, 0.15, 0.05)  # SUNNY
FOGGY = c(0.4, 0.5,  0.1)   # FOGGY
RAINY = c(0.1, 0.3,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
# INITIAL STATE IS RAINY
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
X[1, ] = c(0, 0, 1)
X
for(i in 2:Prediction_Weeks){
# Current state times probability
X[i, ] = X[i-1, ] * P
}
SUNNY = c(0.8, 0.15, 0.05)  # SUNNY
FOGGY = c(0.4, 0.5,  0.1)   # FOGGY
RAINY = c(0.1, 0.3,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
P
X = c(0, 0, 1)
X *P
SUNNY = c(0.8, 0.4, 0.1)  # SUNNY
FOGGY = c(0.15, 0.5,  0.3)   # FOGGY
RAINY = c(0.05, 0.1,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
# INITIAL STATE IS RAINY
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
X = c(0, 0, 1)
X *P
X * P[1,]
X * P[2,]
X * P[3,]
(X *P)[3,]
SUNNY = c(0.8, 0.4, 0.1)  # SUNNY
FOGGY = c(0.15, 0.5,  0.3)   # FOGGY
RAINY = c(0.05, 0.1,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
# INITIAL STATE IS RAINY
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
X[1,] = c(0, 0, 1)
# RUN MARKOV CHAIN
for(i in 2:Prediction_Weeks){
# Current state times probability
X[i, ] = (X[i-1, ] * P)[3,]
}
print(X)
SUNNY = c(0.8, 0.4, 0.1)  # SUNNY
FOGGY = c(0.15, 0.5,  0.3)   # FOGGY
RAINY = c(0.05, 0.1,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
# INITIAL STATE IS RAINY
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
X[1,] = c(0, 0, 1)
# RUN MARKOV CHAIN
for(i in 2:Prediction_Weeks){
# Current state times probability
X[i, ] = X[i-1, ] * P
}
print(X)
X[1,] *P
x2 = c(0.1, 0.3, 0.6)
x2 *P
x2
x[1,]
X[1,]
X[1,] = c(0.1, 0.3, 0.6)
X[1,] *P
SUNNY = c(0.8, 0.4, 0.1)  # SUNNY
FOGGY = c(0.15, 0.5,  0.3)   # FOGGY
RAINY = c(0.05, 0.1,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
X[1,] = c(0, 0, 1)
X = rep(3, NA)
X = rep(NA, 3)
X
X[1,] = c(0, 0, 1)
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
X[1,] = c(0, 0, 1)
X
X[1,]*P
k = (X[1,]*P)[3,]
k
k*P
0.8+0.12+0.6
0.08+0.12+0.06
0.015+0.15+0.180
l = k*P
l
sum(l[,1])
SUNNY = c(0.8, 0.4, 0.1)  # SUNNY
FOGGY = c(0.15, 0.5,  0.3)   # FOGGY
RAINY = c(0.05, 0.1,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
# INITIAL STATE IS RAINY
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
X[1,] = c(0, 0, 1)
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
Prob = X
X[1,] = c(0, 0, 1)
# RUN MARKOV CHAIN
for(i in 2:Prediction_Weeks){
# Current state times probability
Prob[i, ] = X[i-1, ] * P
X[i, ] = c(sum(Prob[,1]), sum(Prob[,2]), sum(Prob[,3]))
}
Prob = X[1, ] * P
Prob
# RUN MARKOV CHAIN
for(i in 2:Prediction_Weeks){
# Current state times probability
Prob = X[i-1, ] * P
X[i, ] = c(sum(Prob[,1]), sum(Prob[,2]), sum(Prob[,3]))
}
print(X)
plot(1:Prediction_Weeks, X[ ,1], xlab="Weeks", Ylab="P(Weather)", ylim=c(0,1),
type="l", lwd=2, col="gold")
plot(1:Prediction_Weeks, X[ ,1], xlab="Weeks", ylab="P(Weather)", ylim=c(0,1),
type="l", lwd=2, col="gold")
lines(1:Prediction_Weeks, X[ ,2], lwd=2, col="gray")
lines(1:Prediction_Weeks, X[ ,3], lwd=2, col="blue")
legend("topright", c("Sunny", "Foggy", "Rainy"), lwd=2, bty="n", col=c("gold", "gray", "blue"))
print(paste("P(Weather) in 1 week = ", X[2, ]))
weather = c("Sunny", "Foggy", "Rainy")
print(paste("P(", Weather, ") in 1 week = ", X[2, ]))
print(paste("P(", weather, ") in 1 week = ", X[2, ]))
print(paste("P(", weather, ") in 6 months = ", X[25, ]))
SUNNY = c(0.8, 0.4, 0.1)  # SUNNY
FOGGY = c(0.15, 0.5,  0.3)   # FOGGY
RAINY = c(0.05, 0.1,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
# INITIAL STATE IS RAINY
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
X[1,] = c(0, 0, 1)
# RUN MARKOV CHAIN
for(i in 2:Prediction_Weeks){
# Current state times probability
Prob = X[i-1, ] * P
X[i, ] = c(sum(Prob[,1]), sum(Prob[,2]), sum(Prob[,3]))
}
print(X)
# PREDICTIONS
weather = c("Sunny", "Foggy", "Rainy")
print(paste("P(", weather, ") in 1 week = ", X[2, ]))
print(paste("P(", weather, ") in 2 week = ", X[3, ]))
print(paste("P(", weather, ") in 6 months = ", X[25, ]))
# DISPLAY
plot(1:Prediction_Weeks, X[ ,1], xlab="Weeks", ylab="P(Weather)", ylim=c(0,1),
type="l", lwd=2, col="gold")
lines(1:Prediction_Weeks, X[ ,2], lwd=2, col="gray")
lines(1:Prediction_Weeks, X[ ,3], lwd=2, col="blue")
legend("topright", c("Sunny", "Foggy", "Rainy"), lwd=2, bty="n", col=c("gold", "gray", "blue"))
SUNNY = c(0.8, 0.4, 0.1)  # SUNNY
FOGGY = c(0.15, 0.5,  0.3)   # FOGGY
RAINY = c(0.05, 0.1,  0.6)   # RAINY
P = matrix(c(SUNNY, FOGGY, RAINY), nrow=3, ncol=3)
print(P)
Prediction_Weeks = 25
# INITIAL STATE IS RAINY
X = mat.or.vec(Prediction_Weeks, length(P[1,]))
X[1,] = c(0, 0, 1)
# RUN MARKOV CHAIN
# RUN MARKOV CHAIN
for(i in 2:Prediction_Weeks){
# Current state times probability
Prob = X[i-1, ] * P
X[i, ] = c(sum(Prob[,1]), sum(Prob[,2]), sum(Prob[,3]))
}
print(X)
# PREDICTIONS
weather = c("Sunny", "Foggy", "Rainy")
print(paste("P(", weather, ") in 1 week = ", X[2, ]))
print(paste("P(", weather, ") in 2 week = ", X[3, ]))
print(paste("P(", weather, ") in 6 months = ", X[25, ]))
# DISPLAY
plot(1:Prediction_Weeks, X[ ,1], xlab="Weeks", ylab="P(Weather)", ylim=c(0,1),
type="l", lwd=2, col="gold")
lines(1:Prediction_Weeks, X[ ,2], lwd=2, col="gray")
lines(1:Prediction_Weeks, X[ ,3], lwd=2, col="blue")
legend("topright", c("Sunny", "Foggy", "Rainy"), lwd=2, bty="n", col=c("gold", "gray", "blue"))
shiny::runApp('Documents/Hadka_OPENMORDM_shinyApps/d19ad051da5542bab1b715fbe388dd77')
runApp('Documents/Hadka_OPENMORDM_shinyApps/d19ad051da5542bab1b715fbe388dd77')
time_years = 2002-1992
sqrt(time_years)
sqrt(10)
shiny::runApp('Documents/Hadka_OPENMORDM_shinyApps/d19ad051da5542bab1b715fbe388dd77')
library(lhs)
setwd("~/Documents/Github_folder/Ruckertetal_SLR2016/RFILES")
rm(list =ls()) #Clear global environment
# Load in R packages
#install.packages("mcmc")
library(mcmc)
library(ncdf)
library(coda)
library(mvtnorm)
library(DEoptim)
library(compiler)
enableJIT(3)
enableJIT(3)
install.packages("mcdf")
rm(list =ls()) #Clear global environment
# Load in R packages
#install.packages("mcmc")
library(mcmc)
library(ncdf4)
library(coda)
library(mvtnorm)
library(DEoptim)
library(compiler)
enableJIT(3)
enableJIT(3)
#--------------------- Step 1: Read in all data. ----------------------------------
# This includes historical temperatures, emission temperatures,
#       and sea-level data.
source("Data/temp_sea_2300.R")
#--------------------- Step 2: Reproduce the Rahmstorf projections: ----------------
# Load the physical sea-level model converted to R from the equaitons in Rahmstorf (2007).
source("Scripts/sealevel_rahm_model.R")
# Physical model parameters
# [1] alpha =  .34      sensitivity of SLR to temperature change (cm/year/C)
# [2] T_0   = -0.5      baseline temp at which the sea level anomaly is zero (C)
# [3] H_0   = -15      initial sea-level anomaly (cm)
# Set vector equal to parameters in Rahmstorf (2007).
original = c(0.34, -0.5, slr[1])
# Run the hindcast in one year incriments from 1880 to 2002.
from = 2 # Start
to = 122 # Number of observations from 1880 to 2002
timestep = 1
hindcast = rahmfunction(original, hist.temp)
# Run the projections using the temperature derived from the IPCC emission scenarios
to = 45     # There are 45 points in this projection from 1880 to 2100
timestep = 5
max_p = rahmfunction(original, max)
min_p = rahmfunction(original, min)
a1fi_p = rahmfunction(original, a1fi)
a1b_p = rahmfunction(original, a1b)
a1t_p = rahmfunction(original, a1t)
a2_p = rahmfunction(original, a2)
b1_p = rahmfunction(original, b1)
b2_p = rahmfunction(original, b2)
# Method: Bayesian homoskedastic (Markov Chain Monte Carlo assuming AR(1) and homoskedastic residuals)
source("Rcali_homo_model_AR.R")
# Set up empty matrices for sea level rate and sea level output.
nyears.obs=length(year) #number of years in observational time series
homo.new.RATE = mat.or.vec(homo_subset_length, nyears.obs)
homo.mcmc.fit = mat.or.vec(homo_subset_length, nyears.obs) # homo.mcmc.fit is the hindcast SLR simulation without noise
to = hindcast_length
# Loop over the sea level model to generate a distribution of sea level rates
# and sea level simulations.
for(i in 1:homo_subset_length) {
# Estimate the sea level rate of change: equation (1)
homo.new.RATE[i,] = alpha.homo.chain[i]*(hist.temp - T_0.homo.chain[i])
homo.mcmc.fit[i,1] = H_0.homo.chain[i]  # Initial value
# Use Forward Euler to estimate sea level over time.
for (n in from:to){
homo.mcmc.fit[i,n] = homo.mcmc.fit[i,n-1] + homo.new.RATE[i,n-1]*timestep
}
}
# Estimate the residuals with the AR(1) coefficient and sigma.
Resid_hindcast_homo = mat.or.vec(homo_subset_length, nyears.obs) #(nr,nc)
for(n in 1:homo_subset_length) {
for(i in 2:nyears.obs) {
# Equation (S4)
Resid_hindcast_homo[n,i] = rho.homo.chain[n]*Resid_hindcast_homo[n,i-1] +
rnorm(1, mean = 0, sd = sigma.homo.chain[n]) # add in the AR(1) noise
}
}
# Estimate the hindcasts: add the residuals onto the model simulations. Equation (2) & (S1)
SLR.homo.hindcasts = mat.or.vec(homo_subset_length, nyears.obs) #(nr,nc)
for(i in 1:homo_subset_length) {
SLR.homo.hindcasts[i,] = homo.mcmc.fit[i,] + Resid_hindcast_homo[i,]
}
#----------------------------- Project Sea-level Rise with Uncertainty --------------------------------
years.mod=(alltime) # all time represent the years from 1880 to 2300
nyears.mod=length(years.mod)
to=projection_length #421
# Set up empty matrices for sea level rate and sea level output.
proj.homo.RATE = mat.or.vec(homo_subset_length, nyears.mod) #(nr,nc)
proj.homo.sim = mat.or.vec(homo_subset_length, nyears.mod) #(nr,nc)
# Loop over the sea level model to generate a distribution of sea level rates
# and sea level simulations.
for(n in 1:homo_subset_length) {
# Estimate the sea level rate of change: equation (1)
proj.homo.RATE[i,] = alpha.homo.chain[n]*(rcp85 - T_0.homo.chain[n])
proj.homo.sim[i,1] = H_0.homo.chain[n]  # Initial value
# Use Forward Euler to estimate sea level over time.
for (i in from:to){
proj.homo.sim[n,i] = proj.homo.sim[n,i-1] + proj.homo.RATE[n,i-1]*timestep
}
}
# Estimate the residuals with the AR(1) coefficient and sigma.
Resid_projection_homo = mat.or.vec(homo_subset_length, nyears.mod) #(nr,nc)
for(n in 1:homo_subset_length) {
for(i in 2:nyears.mod) {
# Equation (S4)
Resid_projection_homo[n,i] = rho.homo.chain[n]*Resid_projection_homo[n,i-1] +
rnorm(1, mean = 0,sd = sigma.homo.chain[n])
}
}
# Estimate the projections: add the residuals onto the model simulations. Equation (2) & (S1)
SLR.projections.homo = mat.or.vec(homo_subset_length, nyears.mod) #(nr,nc)
for(i in 1:homo_subset_length) {
SLR.projections.homo[i,] = proj.homo.sim[i,] + Resid_projection_homo[i,]
}
#--------------------- Estimate PDF, CDF, and SF of SLR in 2100 & 2050 --------------------------
# Load survival function Function
source("Scripts/plot_sf.r")
# Set up a vector for the sea-level anomaly distribution in 2050.
# The year 2050 is the 171 number in the sequence.
prob_proj2050_homo = mat.or.vec(homo_subset_length, 1)
prob_proj2050_homo = SLR.projections.homo[ ,171]
# Estimate the probability density function of sea-level anomalies in 2050.
pdf2050_homo <- density(prob_proj2050_homo/100)
# Estimate the cumulative density function.
cdf2050_homo = ecdf(prob_proj2050_homo/100)
# Estimate the survivial function.
survival2050_homo <- plot.sf(prob_proj2050_homo/100, make.plot=F)
#---
# Set up a vector for the sea-level anomaly distribution in 2100.
# The year 2100 is the 221 number in the sequence.
prob_proj2100_homo = mat.or.vec(homo_subset_length, 1)
prob_proj2100_homo = SLR.projections.homo[ ,221]
# Estimate the probability density function of sea-level anomalies in 2100.
pdf2100_homo <- density(prob_proj2100_homo/100)
# Estimate the cumulative density function.
cdf2100_homo = ecdf(prob_proj2100_homo/100)
# Estimate the survivial function.
survival2100_homo <- plot.sf(prob_proj2100_homo/100, make.plot=F)
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
median(homChainBurnin[,1]); median(homChainBurnin[,2]); median(homChainBurnin[,3])
median(homChainBurnin[,4]); median(homChainBurnin[,5])
# Print the mode estimates (a, T0, H0, sigma, rho).
hom.rounded = round(homChainBurnin,5)
getmode(hom.rounded[,1]); getmode(hom.rounded[,2]); getmode(hom.rounded[,3])
getmode(hom.rounded[,4]); getmode(hom.rounded[,5])
# Print the 99% estimates (a, T0, H0, sigma, rho).
for(i in 1:5){
print(quantile(homChainBurnin[,i], 0.99))
}
# Method: Bayesian heteroskedastic (Markov Chain Monte Carlo assuming AR(1) and heteroskedastic residuals)
source("Rcali_heter_model_AR.R")
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
median(hetChainBurnin[,1]); median(hetChainBurnin[,2]); median(hetChainBurnin[,3])
median(hetChainBurnin[,4]); median(hetChainBurnin[,5])
# Print the mode estimates (a, T0, H0, sigma, rho).
het.rounded = round(hetChainBurnin,5)
getmode(het.rounded[,1]); getmode(het.rounded[,2]); getmode(het.rounded[,3])
getmode(het.rounded[,4]); getmode(het.rounded[,5])
# Print the 99% estimates (a, T0, H0, sigma, rho).
for(i in 1:5){
print(quantile(hetChainBurnin[,i], 0.99))
}
